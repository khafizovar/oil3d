{"version":3,"file":"oceanPostProcess.fragment.js","sourceRoot":"","sources":["../../../sourceES6/postProcessesLibrary/src/ocean/oceanPostProcess.fragment.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,kCAAkC,CAAC;AAE1D,IAAI,IAAI,GAAG,6BAA6B,CAAC;AACzC,IAAI,MAAM,GAAG,okKA0NZ,CAAC;AAEF,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACnC,cAAc;AACd,MAAM,CAAC,IAAI,2BAA2B,GAAG,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC","sourcesContent":["import { Effect } from \"@babylonjs/core/Materials/effect\";\n\nlet name = 'oceanPostProcessPixelShader';\nlet shader = `\n\nuniform sampler2D textureSampler;\nuniform sampler2D positionSampler;\n#ifdef REFLECTION_ENABLED\nuniform sampler2D reflectionSampler;\n#endif\n#ifdef REFRACTION_ENABLED\nuniform sampler2D refractionSampler;\n#endif\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 cameraRotation;\nuniform vec3 cameraPosition;\n\nvarying vec2 vUV;\n\nconst int NUM_STEPS=8;\nconst float PI=3.141592;\nconst float EPSILON=1e-3;\n#define EPSILON_NRM (0.1/resolution.x)\n\nconst int ITER_GEOMETRY=8;\nconst int ITER_FRAGMENT=5;\nconst float SEA_HEIGHT=0.6;\nconst float SEA_CHOPPY=4.0;\nconst float SEA_SPEED=0.8;\nconst float SEA_FREQ=0.16;\nconst vec3 SEA_BASE=vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR=vec3(0.8,0.9,0.6);\n#define SEA_TIME (1.0+time*SEA_SPEED)\nconst mat2 octave_m=mat2(1.6,1.2,-1.2,1.6);\n\nmat3 fromEuler(vec3 ang)\n{\nvec2 a1=vec2(sin(ang.x),cos(ang.x));\nvec2 a2=vec2(sin(ang.y),cos(ang.y));\nvec2 a3=vec2(sin(ang.z),cos(ang.z));\nmat3 m;\nm[0]=vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\nm[1]=vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\nm[2]=vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\nreturn m;\n}\nfloat hash( vec2 p )\n{\nfloat h=dot(p,vec2(127.1,311.7));\nreturn fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p )\n{\nvec2 i=floor( p );\nvec2 f=fract( p );\nvec2 u=f*f*(3.0-2.0*f);\nreturn -1.0+2.0*mix( mix( hash( i+vec2(0.0,0.0) ),\nhash( i+vec2(1.0,0.0) ),u.x),\nmix( hash( i+vec2(0.0,1.0) ),\nhash( i+vec2(1.0,1.0) ),u.x),u.y);\n}\n\nfloat diffuse(vec3 n,vec3 l,float p)\n{\nreturn pow(dot(n,l)*0.4+0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s)\n{\nfloat nrm=(s+8.0)/(PI*8.0);\nreturn pow(max(dot(reflect(e,n),l),0.0),s)*nrm;\n}\n\nfloat sea_octave(vec2 uv,float choppy)\n{\nuv+=noise(uv);\nvec2 wv=1.0-abs(sin(uv));\nvec2 swv=abs(cos(uv));\nwv=mix(wv,swv,wv);\nreturn pow(1.0-pow(wv.x*wv.y,0.65),choppy);\n}\nfloat map(vec3 p)\n{\nfloat freq=SEA_FREQ;\nfloat amp=SEA_HEIGHT;\nfloat choppy=SEA_CHOPPY;\nvec2 uv=p.xz; uv.x*=0.75;\nfloat d,h=0.0;\nfor(int i=0; i<ITER_GEOMETRY; i++)\n{\nd=sea_octave((uv+SEA_TIME)*freq,choppy);\nd+=sea_octave((uv-SEA_TIME)*freq,choppy);\nh+=d*amp;\nuv*=octave_m; freq*=1.9; amp*=0.22;\nchoppy=mix(choppy,1.0,0.2);\n}\nreturn p.y-h;\n}\nfloat map_detailed(vec3 p)\n{\nfloat freq=SEA_FREQ;\nfloat amp=SEA_HEIGHT;\nfloat choppy=SEA_CHOPPY;\nvec2 uv=p.xz; uv.x*=0.75;\nfloat d,h=0.0;\nfor(int i=0; i<ITER_FRAGMENT; i++)\n{\nd=sea_octave((uv+SEA_TIME)*freq,choppy);\nd+=sea_octave((uv-SEA_TIME)*freq,choppy);\nh+=d*amp;\nuv*=octave_m; freq*=1.9; amp*=0.22;\nchoppy=mix(choppy,1.0,0.2);\n}\nreturn p.y-h;\n}\nvec3 getSeaColor(vec3 p,vec3 n,vec3 l,vec3 eye,vec3 dist)\n{\nfloat fresnel=clamp(1.0-dot(n,-eye),0.0,1.0);\nfresnel=pow(fresnel,3.0)*0.65;\n#if defined(REFLECTION_ENABLED) || defined(REFRACTION_ENABLED)\nvec2 reflectionUv=vec2(vUV.x,vUV.y+normalize(n).y);\n#endif\n#ifdef REFLECTION_ENABLED\nvec3 reflected=texture2D(reflectionSampler,reflectionUv).rgb*(1.0-fresnel);\n#else\nvec3 eyeNormal=reflect(eye,n);\neyeNormal.y=max(eyeNormal.y,0.0);\nvec3 reflected=vec3(pow(1.0-eyeNormal.y,2.0),1.0-eyeNormal.y,0.6+(1.0-eyeNormal.y)*0.4);\n#endif\n#ifdef REFRACTION_ENABLED\nvec3 refracted=SEA_BASE+diffuse(n,l,80.0)*SEA_WATER_COLOR*0.12;\nrefracted+=(texture2D(refractionSampler,reflectionUv).rgb*fresnel);\n#else\nvec3 refracted=SEA_BASE+diffuse(n,l,80.0)*SEA_WATER_COLOR*0.12;\n#endif\nvec3 color=mix(refracted,reflected,fresnel);\nfloat atten=max(1.0-dot(dist,dist)*0.001,0.0);\ncolor+=SEA_WATER_COLOR*(p.y-SEA_HEIGHT)*0.18*atten;\ncolor+=vec3(specular(n,l,eye,60.0));\nreturn color;\n}\n\nvec3 getNormal(vec3 p,float eps)\n{\nvec3 n;\nn.y=map_detailed(p);\nn.x=map_detailed(vec3(p.x+eps,p.y,p.z))-n.y;\nn.z=map_detailed(vec3(p.x,p.y,p.z+eps))-n.y;\nn.y=eps;\nreturn normalize(n);\n}\nfloat heightMapTracing(vec3 ori,vec3 dir,out vec3 p)\n{\nfloat tm=0.0;\nfloat tx=1000.0;\nfloat hx=map(ori+dir*tx);\nif(hx>0.0) return tx;\nfloat hm=map(ori+dir*tm);\nfloat tmid=0.0;\nfor(int i=0; i<NUM_STEPS; i++)\n{\ntmid=mix(tm,tx,hm/(hm-hx));\np=ori+dir*tmid;\nfloat hmid=map(p);\nif(hmid<0.0)\n{\ntx=tmid;\nhx=hmid;\n}\nelse\n{\ntm=tmid;\nhm=hmid;\n}\n}\nreturn tmid;\n}\n\nvoid main()\n{\n#ifdef NOT_SUPPORTED\n\ngl_FragColor=texture2D(textureSampler,vUV);\n#else\nvec2 uv=vUV;\nuv=uv*2.0-1.0;\nuv.x*=resolution.x/resolution.y;\n\nvec3 ang=vec3(cameraRotation.z,cameraRotation.x,cameraRotation.y);\nvec3 ori=vec3(cameraPosition.x,cameraPosition.y,-cameraPosition.z);\nvec3 dir=normalize(vec3(uv.xy,-3.0));\ndir=normalize(dir)*fromEuler(ang);\n\nvec3 p;\nheightMapTracing(ori,dir,p);\nvec3 dist=p-ori;\nvec3 n=getNormal(p,dot(dist,dist)*EPSILON_NRM);\nvec3 light=normalize(vec3(0.0,1.0,0.8));\n\nfloat seaFact=clamp(max(ori.y,0.0),0.0,1.0);\nvec3 position=texture2D(positionSampler,vUV).rgb;\nvec3 baseColor=texture2D(textureSampler,vUV).rgb;\nvec3 color=baseColor;\nif (max(position.y,0.0)<p.y)\n{\n\ncolor=mix(\nbaseColor,\ngetSeaColor(p,n,light,dir,dist),\npow(smoothstep(0.0,-0.05,dir.y),0.3)\n)*seaFact;\n}\ncolor=mix(\ncolor,\nbaseColor*SEA_BASE+diffuse(n,n,80.0)*SEA_WATER_COLOR*0.12,\n1.0-seaFact\n);\n\ngl_FragColor=vec4(pow(color,vec3(0.75)),1.0);\n#endif\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var oceanPostProcessPixelShader = { name, shader };\n"]}