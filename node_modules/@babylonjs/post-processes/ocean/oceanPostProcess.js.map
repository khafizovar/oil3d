{"version":3,"file":"oceanPostProcess.js","sourceRoot":"","sources":["../../../sourceES6/postProcessesLibrary/src/ocean/oceanPostProcess.ts"],"names":[],"mappings":"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","sourcesContent":["import { TargetCamera } from \"@babylonjs/core/Cameras/targetCamera\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { MirrorTexture } from \"@babylonjs/core/Materials/Textures/mirrorTexture\";\r\nimport { RenderTargetTexture } from \"@babylonjs/core/Materials/Textures/renderTargetTexture\";\r\nimport { GeometryBufferRenderer } from \"@babylonjs/core/Rendering/geometryBufferRenderer\";\r\nimport { Effect } from \"@babylonjs/core/Materials/effect\";\r\nimport { PostProcess } from \"@babylonjs/core/PostProcesses/postProcess\";\r\nimport { Vector2, Vector3, Plane, Matrix, Epsilon } from \"@babylonjs/core/Maths/math\";\r\nimport { Nullable } from \"@babylonjs/core/types\";\r\n\r\nimport \"./oceanPostProcess.fragment\";\r\n\r\n/**\r\n * Option available in the Ocean Post Process.\r\n */\r\nexport interface IOceanPostProcessOptions {\r\n    /**\r\n     * The size of the reflection RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)\r\n     */\r\n    reflectionSize?: number | { width: number; height: number } | { ratio: number };\r\n    /**\r\n     * The size of the refraction RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)\r\n     */\r\n    refractionSize?: number | { width: number; height: number } | { ratio: number };\r\n}\r\n\r\n/**\r\n * OceanPostProcess helps rendering an infinite ocean surface that can reflect and refract environment.\r\n *\r\n * Simmply add it to your scene and let the nerd that lives in you have fun.\r\n * Example usage:\r\n *  var pp = new OceanPostProcess(\"myOcean\", camera);\r\n *  pp.reflectionEnabled = true;\r\n *  pp.refractionEnabled = true;\r\n */\r\nexport class OceanPostProcess extends PostProcess {\r\n\r\n    /**\r\n     * Gets a boolean indicating if the real-time reflection is enabled on the ocean.\r\n     */\r\n    public get reflectionEnabled(): boolean {\r\n        return this._reflectionEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets weither or not the real-time reflection is enabled on the ocean.\r\n     * Is set to true, the reflection mirror texture will be used as reflection texture.\r\n     */\r\n    public set reflectionEnabled(enabled: boolean) {\r\n        if (this._reflectionEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._reflectionEnabled = enabled;\r\n        this.updateEffect(this._getDefines());\r\n\r\n        // Remove or add custom render target\r\n        const customRenderTargets = this.getCamera().getScene().customRenderTargets;\r\n        if (!enabled) {\r\n            const index = customRenderTargets.indexOf(this.reflectionTexture);\r\n            if (index !== -1) {\r\n                customRenderTargets.splice(index, 1);\r\n            }\r\n        } else {\r\n            customRenderTargets.push(this.reflectionTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the real-time refraction is enabled on the ocean.\r\n     */\r\n    public get refractionEnabled(): boolean {\r\n        return this._refractionEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets weither or not the real-time refraction is enabled on the ocean.\r\n     * Is set to true, the refraction render target texture will be used as refraction texture.\r\n     */\r\n    public set refractionEnabled(enabled: boolean) {\r\n        if (this._refractionEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._refractionEnabled = enabled;\r\n        this.updateEffect(this._getDefines());\r\n\r\n        // Remove or add custom render target\r\n        const customRenderTargets = this.getCamera().getScene().customRenderTargets;\r\n        if (!enabled) {\r\n            const index = customRenderTargets.indexOf(this.refractionTexture);\r\n            if (index !== -1) {\r\n                customRenderTargets.splice(index, 1);\r\n            }\r\n        } else {\r\n            customRenderTargets.push(this.refractionTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets wether or not the post-processes is supported by the running hardware.\r\n     * This requires draw buffer supports.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._geometryRenderer !== null && this._geometryRenderer.isSupported;\r\n    }\r\n\r\n    /**\r\n     * This is the reflection mirror texture used to display reflections on the ocean.\r\n     * By default, render list is empty.\r\n     */\r\n    public reflectionTexture: MirrorTexture;\r\n    /**\r\n     * This is the refraction render target texture used to display refraction on the ocean.\r\n     * By default, render list is empty.\r\n     */\r\n    public refractionTexture: RenderTargetTexture;\r\n\r\n    private _time: number = 0;\r\n    private _cameraRotation: Vector3 = Vector3.Zero();\r\n    private _cameraViewMatrix: Matrix = Matrix.Identity();\r\n    private _reflectionEnabled: boolean = false;\r\n    private _refractionEnabled: boolean = false;\r\n    private _geometryRenderer: Nullable<GeometryBufferRenderer>;\r\n\r\n    /**\r\n     * Instantiates a new Ocean Post Process.\r\n     * @param name the name to give to the postprocess.\r\n     * @camera the camera to apply the post process to.\r\n     * @param options optional object following the IOceanPostProcessOptions format used to customize reflection and refraction render targets sizes.\r\n     */\r\n    constructor(name: string, camera: TargetCamera, options: IOceanPostProcessOptions = { }) {\r\n        super(name,\r\n            \"oceanPostProcess\",\r\n            [\"time\", \"resolution\", \"cameraPosition\", \"cameraRotation\"],\r\n            [\"positionSampler\", \"reflectionSampler\", \"refractionSampler\"],\r\n            {\r\n                width: camera.getEngine().getRenderWidth(),\r\n                height: camera.getEngine().getRenderHeight()\r\n            },\r\n            camera,\r\n            Texture.TRILINEAR_SAMPLINGMODE,\r\n            camera.getEngine(),\r\n            true);\r\n\r\n        // Get geometry shader\r\n        this._geometryRenderer = camera.getScene().enableGeometryBufferRenderer(1.0);\r\n        if (this._geometryRenderer && this._geometryRenderer.isSupported) {\r\n            // Eanble position buffer\r\n            this._geometryRenderer.enablePosition = true;\r\n\r\n            // Create mirror textures\r\n            this.reflectionTexture = new MirrorTexture(\"oceanPostProcessReflection\", options.reflectionSize || { width: 512, height: 512 }, camera.getScene());\r\n            this.reflectionTexture.mirrorPlane = Plane.FromPositionAndNormal(Vector3.Zero(), new Vector3(0, -1, 0));\r\n\r\n            this.refractionTexture = new RenderTargetTexture(\"oceanPostProcessRefraction\", options.refractionSize || { width: 512, height: 512 }, camera.getScene());\r\n        } else {\r\n            this.updateEffect(\"#define NOT_SUPPORTED\\n\");\r\n        }\r\n\r\n        // On apply the post-process\r\n        this.onApply = (effect: Effect) => {\r\n            if (!this._geometryRenderer || !this._geometryRenderer.isSupported) {\r\n                return;\r\n            }\r\n\r\n            const engine = camera.getEngine();\r\n            const scene = camera.getScene();\r\n\r\n            this._time += engine.getDeltaTime() * 0.001;\r\n            effect.setFloat(\"time\", this._time);\r\n\r\n            effect.setVector2(\"resolution\", new Vector2(engine.getRenderWidth(), engine.getRenderHeight()));\r\n\r\n            if (scene) {\r\n                // Position\r\n                effect.setVector3(\"cameraPosition\", camera.globalPosition);\r\n\r\n                // Rotation\r\n                this._computeCameraRotation(camera);\r\n                effect.setVector3(\"cameraRotation\", this._cameraRotation);\r\n\r\n                // Samplers\r\n                effect.setTexture(\"positionSampler\", this._geometryRenderer.getGBuffer().textures[2]);\r\n\r\n                if (this._reflectionEnabled) {\r\n                    effect.setTexture(\"reflectionSampler\", this.reflectionTexture);\r\n                }\r\n                if (this._refractionEnabled) {\r\n                    effect.setTexture(\"refractionSampler\", this.refractionTexture);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the appropriate defines according to the current configuration.\r\n     */\r\n    private _getDefines(): string {\r\n        const defines: string[] = [];\r\n\r\n        if (this._reflectionEnabled) {\r\n            defines.push(\"#define REFLECTION_ENABLED\");\r\n        }\r\n\r\n        if (this._refractionEnabled) {\r\n            defines.push(\"#define REFRACTION_ENABLED\");\r\n        }\r\n\r\n        return defines.join(\"\\n\");\r\n    }\r\n\r\n    /**\r\n     * Computes the current camera rotation as the shader requires a camera rotation.\r\n     */\r\n    private _computeCameraRotation(camera: TargetCamera): void {\r\n        camera.upVector.normalize();\r\n        const target = camera.getTarget();\r\n        camera._initialFocalDistance = target.subtract(camera.position).length();\r\n        if (camera.position.z === target.z) {\r\n            camera.position.z += Epsilon;\r\n        }\r\n\r\n        const direction = target.subtract(camera.position);\r\n        camera._viewMatrix.invertToRef(this._cameraViewMatrix);\r\n\r\n        this._cameraRotation.x = Math.atan(this._cameraViewMatrix.m[6] / this._cameraViewMatrix.m[10]);\r\n\r\n        if (direction.x >= 0.0) {\r\n            this._cameraRotation.y = (-Math.atan(direction.z / direction.x) + Math.PI / 2.0);\r\n        } else {\r\n            this._cameraRotation.y = (-Math.atan(direction.z / direction.x) - Math.PI / 2.0);\r\n        }\r\n\r\n        this._cameraRotation.z = 0;\r\n\r\n        if (isNaN(this._cameraRotation.x)) {\r\n            this._cameraRotation.x = 0;\r\n        }\r\n\r\n        if (isNaN(this._cameraRotation.y)) {\r\n            this._cameraRotation.y = 0;\r\n        }\r\n\r\n        if (isNaN(this._cameraRotation.z)) {\r\n            this._cameraRotation.z = 0;\r\n        }\r\n    }\r\n}\r\n"]}